#!/usr/bin/env zsh

REPO_ROOT=$(git rev-parse --show-toplevel 2>/dev/null)
[[ ! -f "$REPO_ROOT/CMakeLists.txt" ]] && exit 0
cd "$REPO_ROOT"

PROTECTED_BRANCHES="^(main|staging)$"
CURRENT_BRANCH=$(git symbolic-ref --short HEAD 2>/dev/null)
GIT_DIR=$(git rev-parse --git-dir)

if [[ "$CURRENT_BRANCH" =~ $PROTECTED_BRANCHES ]]; then
    [[ -f "$GIT_DIR/MERGE_HEAD" ]] && exit 0
    echo "error: direct commits to '$CURRENT_BRANCH' are blocked"
    echo "use: git flow <type> start <name>"
    exit 1
fi

VALID_PREFIXES="^(feat|fix|hot|rel|misc|docs|refactor|test|chore|perf|ci|build|revert)/"
if [[ -n "$CURRENT_BRANCH" && ! "$CURRENT_BRANCH" =~ $VALID_PREFIXES ]]; then
    echo "error: invalid branch name '$CURRENT_BRANCH'"
    echo ""
    echo "valid prefixes: feat/ fix/ hot/ rel/ misc/ docs/ refactor/ test/ chore/ perf/ ci/ build/ revert/"
    echo "example: feat/task-state, fix/null-deref, hot/security-patch"
    exit 1
fi

ERRORS=""

if [[ -f ".mainproj" && -f "CMakeLists.txt" ]]; then
    if ! grep -qE 'include\(std\)' CMakeLists.txt 2>/dev/null; then
        ERRORS+="error: std.cmake not sourced\n\n"
        ERRORS+="CMakeLists.txt must include:\n"
        ERRORS+="  list(APPEND CMAKE_MODULE_PATH \"\$ENV{HOME}/.config/cmake\")\n"
        ERRORS+="  include(std)\n\n"
    fi

    STAGED_HEADERS=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.h$' || true)
    if [[ -n "$STAGED_HEADERS" ]]; then
        INVALID_ERRCODES=""
        while IFS= read -r hdr; do
            [[ -z "$hdr" ]] && continue
            while IFS= read -r line; do
                code=$(echo "$line" | grep -oP '#define\s+\w*ERR\w*\s+\K\d+' || true)
                [[ -z "$code" ]] && continue
                if [[ "$code" -ge 0 && "$code" -le 690 ]]; then
                    INVALID_ERRCODES+="  $hdr: $line\n"
                fi
            done < <(grep -E '#define\s+\w*ERR\w*\s+[0-9]+' "$hdr" 2>/dev/null || true)
        done <<< "$STAGED_HEADERS"
        if [[ -n "$INVALID_ERRCODES" ]]; then
            ERRORS+="error: error codes in reserved libdangling range (0-690)\n\n"
            ERRORS+="$INVALID_ERRCODES\n"
            ERRORS+="project error codes must be in range 700-990\n\n"
        fi
    fi
fi

C_STAGED_ALL=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(c|h)$' || true)
C_STAGED_CHECK=$(echo "$C_STAGED_ALL" | grep -vE '^tests/|/tests/|^test_|/test_' || true)
if [[ -n "$C_STAGED_CHECK" ]]; then
    STATE_FILE=".test-state"
    COVERAGE_MIN=50
    NEED_TESTS=1

    if [[ -f "$STATE_FILE" ]]; then
        source "$STATE_FILE"
        CURRENT_HASH=$(find src source -name '*.[ch]' -o -name '*.cpp' -o -name '*.hpp' 2>/dev/null | sort | xargs sha256sum 2>/dev/null | sha256sum | cut -d' ' -f1)
        if [[ "$CURRENT_HASH" == "$hash" ]] && (( $(echo "$coverage >= $COVERAGE_MIN" | bc -l 2>/dev/null || echo 0) )); then
            BUILD_DIR=""
            [[ -f "build/coverage.info" ]] && BUILD_DIR="build"
            [[ -f "coverage.info" ]] && BUILD_DIR="."
            if [[ -n "$BUILD_DIR" ]] && command -v lcov &>/dev/null; then
                C_SOURCE_FILES=$(echo "$C_STAGED_CHECK" | grep -E '\.c$' || true)
                echo "test state A-OK; project: ${coverage}%"
                LOW_COV=""
                while IFS= read -r file; do
                    [[ -z "$file" ]] && continue
                    [[ "$(basename "$file")" == "main.c" || "$(basename "$file")" == *_main.c || "$(basename "$file")" == "tui.c" || "$(basename "$file")" == *_tui.c || "$(basename "$file")" == "err.c" || "$(basename "$file")" == *_err.c || "$(basename "$file")" == "bindings.c" || "$(basename "$file")" == *_bindings.c || "$(basename "$file")" == "repl.c" || "$(basename "$file")" == *_repl.c || "$(basename "$file")" == "daemon.c" || "$(basename "$file")" == *_daemon.c ]] && continue
                    [[ "$file" == tests/* || "$file" == */tui/* || "$(basename "$file")" == test_* ]] && continue
                    FILE_COV=$(lcov --summary "$BUILD_DIR/coverage.info" --include "*/$file" 2>&1 | grep -oP 'lines\.*:\s*\K[0-9.]+' | head -1 || echo "0")
                    [[ -z "$FILE_COV" ]] && FILE_COV="0"
                    echo "  ${file}: ${FILE_COV}%"
                    if (( $(echo "$FILE_COV < $COVERAGE_MIN" | bc -l 2>/dev/null || echo 1) )); then
                        LOW_COV+="  ${file}: ${FILE_COV}%\n"
                    fi
                done <<< "$C_SOURCE_FILES"
                if [[ -n "$LOW_COV" ]]; then
                    ERRORS+="error: staged files below ${COVERAGE_MIN}% coverage\n\n"
                    ERRORS+="$LOW_COV\n"
                    SCOPE_FILE=$(git rev-parse --git-dir)/COMMIT_SCOPE
                    if [[ -f "$SCOPE_FILE" ]]; then
                        SCOPE=$(cat "$SCOPE_FILE")
                        SCOPE_BASE=$(basename "$SCOPE")
                        ERRORS+="suggested test location: tests/test_${SCOPE_BASE}.c\n\n"
                    fi
                fi
            else
                echo "test state A-OK; project: ${coverage}%"
            fi
            NEED_TESTS=0
        fi
    fi

    if [[ $NEED_TESTS -eq 1 ]]; then
        BUILD_DIR=""
        [[ -f "build/Makefile" ]] && BUILD_DIR="build"
        [[ -f "Makefile" && -z "$BUILD_DIR" ]] && BUILD_DIR="."

        if [[ -n "$BUILD_DIR" ]]; then
            echo "running tests for staged C files..."
            TEST_OUT=$(make -C "$BUILD_DIR" tests-run 2>&1)
            TEST_RC=$?

            if [[ $TEST_RC -ne 0 ]]; then
                ERRORS+="error: tests failed\n\n"
                ERRORS+="$(echo "$TEST_OUT" | tail -30)\n\n"
            fi

            if [[ -f "$BUILD_DIR/coverage.info" ]] && command -v lcov &>/dev/null; then
                C_SOURCE_FILES=$(echo "$C_STAGED_CHECK" | grep -E '\.c$' || true)
                PROJ_COV=$(lcov --summary "$BUILD_DIR/coverage.info" 2>&1 | grep -oP 'lines\.*:\s*\K[0-9.]+' | head -1 || echo "0")
                echo "coverage; project: ${PROJ_COV}%"
                LOW_COVERAGE=""
                while IFS= read -r file; do
                    [[ -z "$file" ]] && continue
                    [[ "$(basename "$file")" == "main.c" || "$(basename "$file")" == *_main.c || "$(basename "$file")" == "tui.c" || "$(basename "$file")" == *_tui.c || "$(basename "$file")" == "err.c" || "$(basename "$file")" == *_err.c || "$(basename "$file")" == "bindings.c" || "$(basename "$file")" == *_bindings.c || "$(basename "$file")" == "repl.c" || "$(basename "$file")" == *_repl.c || "$(basename "$file")" == "daemon.c" || "$(basename "$file")" == *_daemon.c ]] && continue
                    [[ "$file" == tests/* || "$file" == */tui/* || "$(basename "$file")" == test_* ]] && continue
                    FILE_COV=$(lcov --summary "$BUILD_DIR/coverage.info" --include "*/$file" 2>&1 | grep -oP 'lines\.*:\s*\K[0-9.]+' | head -1 || echo "0")
                    [[ -z "$FILE_COV" ]] && FILE_COV="0"
                    echo "  ${file}: ${FILE_COV}%"
                    if (( $(echo "$FILE_COV < $COVERAGE_MIN" | bc -l 2>/dev/null || echo 1) )); then
                        LOW_COVERAGE+="  $file: ${FILE_COV}%\n"
                    fi
                done <<< "$C_SOURCE_FILES"

                if [[ -n "$LOW_COVERAGE" ]]; then
                    ERRORS+="error: staged files below ${COVERAGE_MIN}% coverage\n\n"
                    ERRORS+="$LOW_COVERAGE\n"
                    SCOPE_FILE=$(git rev-parse --git-dir)/COMMIT_SCOPE
                    if [[ -f "$SCOPE_FILE" ]]; then
                        SCOPE=$(cat "$SCOPE_FILE")
                        SCOPE_BASE=$(basename "$SCOPE")
                        ERRORS+="suggested test location: tests/test_${SCOPE_BASE}.c\n\n"
                    fi
                fi

                if [[ -z "$ERRORS" ]]; then
                    "$HOME/.config/git/bin/git-test-state" save
                fi
            fi
        fi
    fi
fi

BANNED_EXT="\.(so|a|o|dylib|dll|exe|bin|out|class|jar|pyc|pyo|whl|egg|png|jpg|jpeg|gif|bmp|ico|tiff|webp|mp3|mp4|wav|avi|mov|mkv|pdf|doc|docx|xls|xlsx|ppt|pptx|zip|tar|gz|bz2|xz|7z|rar|iso|dmg|pkg|deb|rpm)$"
BANNED_FILES=$(git diff --cached --name-only --diff-filter=ACMR | grep -iE "$BANNED_EXT" || true)
if [[ -n "$BANNED_FILES" ]]; then
    ERRORS+="error: binary/media files not allowed in commits\n\n"
    ERRORS+="$(echo "$BANNED_FILES" | sed 's/^/  /')\n\n"
    ERRORS+="use git-lfs for large/binary files\n\n"
fi

ELF_FILES=""
for f in $(git diff --cached --name-only --diff-filter=ACMR 2>/dev/null); do
    [[ -f "$f" ]] && file "$f" 2>/dev/null | grep -q "ELF" && ELF_FILES+="  $f\n"
done
if [[ -n "$ELF_FILES" ]]; then
    ERRORS+="error: ELF binaries not allowed in commits\n\n"
    ERRORS+="$ELF_FILES\n"
fi

UNCRUSTIFY_CFG="$HOME/git/.uncrustify.cfg"
if [[ -f "$UNCRUSTIFY_CFG" ]] && command -v uncrustify &>/dev/null; then
    C_FILES=$(git diff --cached --name-only --diff-filter=ACMR | grep -E '\.(c|h)$' || true)
    if [[ -n "$C_FILES" ]]; then
        echo "$C_FILES" | while IFS= read -r file; do
            uncrustify -c "$UNCRUSTIFY_CFG" --no-backup -q "$file"
            git add "$file"
        done
    fi
fi

C_STAGED=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\.(c|h)$' || true)
if [[ -n "$C_STAGED" ]]; then
    INVALID=$(echo "$C_STAGED" | xargs -r "$HOME/.config/git/bin/c-func-name-check" 2>/dev/null || true)
    if [[ -n "$INVALID" ]]; then
        ERRORS+="error: function names must end with a verb\n\n$INVALID\n"
    fi
fi

if [[ -n "$C_STAGED" ]]; then
    SIGNED_TYPES=""
    while IFS= read -r file; do
        [[ -z "$file" ]] && continue
        DIFF_CONTENT=$(git diff --cached -U0 "$file" 2>/dev/null | grep -E '^\+' | grep -v '^+++' || true)
        [[ -z "$DIFF_CONTENT" ]] && continue
        VIOLATIONS=$(echo "$DIFF_CONTENT" | grep -vE '^\+\s*//' | grep -vE '^\+\s*\*' | grep -vE '"[^"]*%[^"]*"' | grep -vE '#include' | grep -vE 'extern\s' | grep -vE '\([a-z_]+\)' | grep -E '\b(signed|short|long|int|int8_t|int16_t|int32_t|int64_t|intptr_t|size_t|ssize_t)\b' | grep -vE '\buint' | head -5 || true)
        if [[ -n "$VIOLATIONS" ]]; then
            SIGNED_TYPES+="  $file:\n"
            SIGNED_TYPES+="$(echo "$VIOLATIONS" | sed 's/^/    /')\n"
        fi
    done <<< "$C_STAGED"
    if [[ -n "$SIGNED_TYPES" ]]; then
        echo -e "\033[1;33m!!! WARNING: SIGNED/AMBIGUOUS INTEGER TYPES DETECTED !!!\033[0m\n"
        echo -e "$SIGNED_TYPES"
        echo -e "\033[1;33mint allowed for POSIX fds; prefer: uint8_t uint16_t uint32_t uint64_t uintptr_t\033[0m\n"
    fi
fi

C_STAGED_SRC=$(echo "$C_STAGED" | grep -E '\.c$' || true)
if [[ -n "$C_STAGED_SRC" ]]; then
    PROTOTYPES=""
    while IFS= read -r file; do
        [[ -z "$file" ]] && continue
        PROTO_LINES=$(grep -nE '^\s*(static\s+)?(const\s+)?(void|uint8_t|uint16_t|uint32_t|uint64_t|uintptr_t|float|double|struct\s+\w+|enum\s+\w+|\w+_t)[\s*]+\w+\s*\([^)]*\)\s*;' "$file" 2>/dev/null | head -5 || true)
        if [[ -n "$PROTO_LINES" ]]; then
            PROTOTYPES+="  $file:\n"
            PROTOTYPES+="$(echo "$PROTO_LINES" | sed 's/^/    /')\n"
        fi
    done <<< "$C_STAGED_SRC"
    if [[ -n "$PROTOTYPES" ]]; then
        ERRORS+="error: function prototypes in source files\n\n"
        ERRORS+="$PROTOTYPES\n"
        ERRORS+="prototypes belong in headers; order functions by dependency\n\n"
    fi
fi

if [[ -n "$C_STAGED_SRC" ]]; then
    GLOBALS=""
    while IFS= read -r file; do
        [[ -z "$file" ]] && continue
        GLOBAL_LINES=$(grep -nE '^(static\s+)?(const\s+)?(volatile\s+)?(uint8_t|uint16_t|uint32_t|uint64_t|uintptr_t|float|double|char|void\s*\*|\w+_t)\s+\w+\s*(=|;|\[)' "$file" 2>/dev/null | grep -vE '\(|^[0-9]+:static\s+const\s' | head -5 || true)
        if [[ -n "$GLOBAL_LINES" ]]; then
            GLOBALS+="  $file:\n"
            GLOBALS+="$(echo "$GLOBAL_LINES" | sed 's/^/    /')\n"
        fi
    done <<< "$C_STAGED_SRC"
    if [[ -n "$GLOBALS" ]]; then
        echo -e "\033[1;33m!!! WARNING: GLOBAL/FILE-SCOPE VARIABLES DETECTED !!!\033[0m\n"
        echo -e "$GLOBALS"
        echo -e "\033[1;33mtop-level declarations are prohibited; use function-local scope\033[0m\n"
    fi
fi

if [[ -n "$C_STAGED" ]]; then
    PRAGMAS=""
    while IFS= read -r file; do
        [[ -z "$file" ]] && continue
        PRAGMA_LINES=$(grep -nE '^\s*#\s*pragma\s' "$file" 2>/dev/null | head -5 || true)
        if [[ -n "$PRAGMA_LINES" ]]; then
            PRAGMAS+="  $file:\n"
            PRAGMAS+="$(echo "$PRAGMA_LINES" | sed 's/^/    /')\n"
        fi
    done <<< "$C_STAGED"
    if [[ -n "$PRAGMAS" ]]; then
        ERRORS+="error: #pragma directives forbidden\n\n"
        ERRORS+="$PRAGMAS\n"
        ERRORS+="refactor code to satisfy static analyzers\n\n"
    fi
fi

if [[ -n "$C_STAGED" ]] && command -v cppcheck &>/dev/null; then
    SRC_DIRS=""
    [[ -d "src" ]] && SRC_DIRS="src"
    [[ -d "source" ]] && SRC_DIRS="source"
    [[ -d "include" ]] && SRC_DIRS="$SRC_DIRS include"
    if [[ -n "$SRC_DIRS" ]]; then
        STAGED_PATTERN=$(echo "$C_STAGED" | tr '\n' '|' | sed 's/|$//')
        CPPCHECK_OUT=$(cppcheck --enable=warning,style,performance --error-exitcode=0 --quiet $SRC_DIRS 2>&1 | grep -E "^($STAGED_PATTERN):" | grep -v "^$" || true)
        if [[ -n "$CPPCHECK_OUT" ]]; then
            ERRORS+="cppcheck:\n$CPPCHECK_OUT\n\n"
        fi
    fi
fi

if [[ -n "$C_STAGED" ]] && command -v clang-tidy &>/dev/null; then
    COMPILE_DB=""
    [[ -f "compile_commands.json" ]] && COMPILE_DB="."
    [[ -f "build/compile_commands.json" ]] && COMPILE_DB="build"
    if [[ -n "$COMPILE_DB" ]]; then
        TIDY_OUT=$(echo "$C_STAGED" | xargs -r clang-tidy -p "$COMPILE_DB" --quiet --extra-arg=-Wno-unknown-warning-option --extra-arg=-Wno-error=unknown-argument 2>&1 | grep -E "warning:|error:" | grep -v "clang-diagnostic" | head -30 || true)
        if [[ -n "$TIDY_OUT" ]]; then
            ERRORS+="clang-tidy:\n$TIDY_OUT\n\n"
        fi
    fi
fi

if [[ -n "$C_STAGED" ]] && command -v lizard &>/dev/null; then
    COMPLEX=$(echo "$C_STAGED" | xargs -r lizard -CCN15 -w 2>/dev/null | grep "!!!" || true)
    if [[ -n "$COMPLEX" ]]; then
        ERRORS+="complexity (CCN>15):\n$COMPLEX\n\n"
    fi
fi

COCCI_RUNNER="$HOME/.config/git/cocci/run-all.sh"
if [[ -n "$C_STAGED_SRC" ]] && [[ -x "$COCCI_RUNNER" ]] && command -v spatch &>/dev/null; then
    COCCI_OUT=$("$COCCI_RUNNER" "$REPO_ROOT/src" 2>&1 || true)
    if echo "$COCCI_OUT" | grep -qE "^issues: [1-9]"; then
        ERRORS+="coccinelle:\n$COCCI_OUT\n\n"
    fi
fi

PROSE_STAGED=$(git diff --cached --name-only --diff-filter=ACM | grep -iE '\.(md|txt|rst|adoc)$' | grep -v 'CMakeLists.txt' || true)
VALE_FILTER="TooWordy|Profanity|Microsoft\.(Auto|Foreign|Avoid|Dashes)|Passive|Weasel|Condescending|Typography"
LT_FILTER="MORFOLOGIK_RULE|WHITESPACE|COMMA_PARENTHESIS|UPPERCASE_SENTENCE|EN_QUOTES|premium:"
if [[ -n "$PROSE_STAGED" ]] && command -v vale &>/dev/null; then
    VALE_CFG="$HOME/.config/vale/.vale.ini"
    if [[ -f "$VALE_CFG" ]]; then
        VALE_OUT=$(echo "$PROSE_STAGED" | xargs -r vale --config="$VALE_CFG" --output=line 2>&1 | grep -vE "$VALE_FILTER" || true)
        if [[ -n "$VALE_OUT" ]]; then
            ERRORS+="vale (prose linting):\n$VALE_OUT\n\n"
        fi
    fi
fi


if [[ -n "$PROSE_STAGED" ]] && command -v harper-cli &>/dev/null; then
    HARPER_OUT=""
    while IFS= read -r file; do
        [[ -z "$file" ]] && continue
        LINT_COUNT=$(harper-cli lint --count "$file" 2>&1 | grep -oP '\d+(?= lints)' | head -1 || echo "0")
        [[ "$LINT_COUNT" -gt 50 ]] && HARPER_OUT+="$file: $LINT_COUNT lints\n"
    done <<< "$PROSE_STAGED"
    if [[ -n "$HARPER_OUT" ]]; then
        ERRORS+="harper:\n$HARPER_OUT\n"
    fi
fi

STAGED_FILES=$(git diff --cached --name-only --diff-filter=ACMRD | grep "^src/" || true)

if [[ -n "$STAGED_FILES" ]]; then
    SCOPES=""
    while IFS= read -r file; do
        scope="${file#src/}"
        depth=$(echo "$scope" | tr '/' '\n' | wc -l)
        if [[ "$depth" -gt 3 ]]; then
            scope=$(dirname "$scope")
        else
            scope="${scope%.*}"
        fi
        SCOPES="$SCOPES$scope"$'\n'
    done <<< "$STAGED_FILES"

    SUBSYSTEMS=$(echo "$SCOPES" | cut -d'/' -f1-2 | sort -u)
    SUBSYSTEM_COUNT=$(echo "$SUBSYSTEMS" | grep -c . || echo 0)

    if [[ "$SUBSYSTEM_COUNT" -gt 1 ]]; then
        ERRORS+="error: cross-subsystem commit detected\n\n"
        ERRORS+="staged files span multiple subsystems:\n"
        ERRORS+="$(echo "$SUBSYSTEMS" | sed 's/^/  /')\n\n"
        ERRORS+="commits must be atomic within a single subsystem\n"
        ERRORS+="split into separate commits per subsystem\n\n"
    fi

    MODULES=$(echo "$SCOPES" | sort -u)
    MODULE_COUNT=$(echo "$MODULES" | grep -c . || echo 0)

    if [[ "$MODULE_COUNT" -gt 1 ]]; then
        ERRORS+="error: cross-module commit detected\n\n"
        ERRORS+="staged files span multiple modules:\n"
        ERRORS+="$(echo "$MODULES" | sed 's/^/  /')\n\n"
        ERRORS+="commits must be atomic within a single module\n"
        ERRORS+="split into separate commits per module\n\n"
    fi

    if [[ -z "$ERRORS" ]]; then
        SCOPE=$(echo "$SCOPES" | head -n1 | tr -d '\n')
        SCOPE_DIR=$(dirname "$SCOPE")
        SCOPE_BASE=$(basename "$SCOPE")
        SCOPE_PARENT=$(basename "$SCOPE_DIR")
        if [[ "$SCOPE_BASE" == "$SCOPE_PARENT" ]]; then
            SCOPE="$SCOPE_DIR"
        fi
        echo "$SCOPE" > "$(git rev-parse --git-dir)/COMMIT_SCOPE"
    fi
fi

if [[ -n "$ERRORS" ]]; then
    echo -e "$ERRORS"
    exit 1
fi

exit 0
